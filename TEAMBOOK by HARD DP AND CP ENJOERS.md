
# **TEAMBOOK by HARD DP AND CP ENJOYERS**
#### Владимир Архипов, Игорь Красавченко, Михаил Жемчужников
**the best team ever, and we look like this**

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠤⠤⠠⡖⠲⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡠⠶⣴⣶⣄⠀⠀⠀⢀⣴⣞⣼⣴⣖⣶⣾⡷⣶⣿⣿⣷⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⠀⠙⢟⠛⠴⣶⣿⣿⠟⠙⣍⠑⢌⠙⢵⣝⢿⣽⡮⣎⢿⡦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⢱⡶⣋⠿⣽⣸⡀⠘⣎⢢⡰⣷⢿⣣⠹⣿⢸⣿⢿⠿⡦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⢧⡿⣇⡅⣿⣇⠗⢤⣸⣿⢳⣹⡀⠳⣷⣻⣼⢿⣯⡷⣿⣁⠒⠠⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⣼⣿⣧⡏⣿⣿⢾⣯⡠⣾⣸⣿⡿⣦⣙⣿⢹⡇⣿⣷⣝⠿⣅⣂⡀⠀⠡⢂⠄⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠇⠀⠀⠀⠀⣿⡟⣿⡇⡏⣿⣽⣿⣧⢻⡗⡇⣇⣤⣿⣿⣿⣧⣿⣿⡲⣭⣀⡭⠛⠁⠀⠀⠈⠀⠉⢂⢄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠸⠀⠀⠀⠀⢻⣿⣇⣥⣏⣘⣿⣏⠛⠻⣷⠿⡻⡛⠷⡽⡿⣿⣿⣿⣷⠟⠓⠉⠢⢄⡀⠀⠀⠀⠀⠀⠁⠫⢢⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⢸⣾⣿⣽⣿⣏⣻⠻⠁⢠⠁⠀⠀⠀⠘⣰⣿⣿⢟⢹⢻⠀⠀⠀⠀⠀⠈⠒⢄⡀⠀⠀⠀⠀⠀⠀⠑⢄
⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⢸⣯⣿⣿⣿⢷⡀⠀⠀⠀⠀⠀⠀⠀⠛⣩⣿⣿⢿⣾⣸⠀⠀⠀⠀⠀⠀⢀⡠⠚⠉⠉⠁⠀⠀⠀⢀⠌
⠀⠀⠀⠀⠀⠀⠀⢡⠀⠀⠀⢟⣿⣯⡟⠿⡟⢇⡀⠀⠀⠐⠁⢀⢴⠋⡼⢣⣿⣻⡏⠀⠀⠀⣀⠄⠂⠁⠀⠀⠀⠀⠀⠀⢀⡤⠂⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠈⠊⢻⣿⣜⡹⡀⠈⠱⠂⠤⠔⠡⢶⣽⡷⢟⡿⠕⠒⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⡠⠐⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⢿⠿⠿⢿⠾⣽⡀⠀⠀⠀⠈⠻⣥⣃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠒⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⡀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣖⠂⠠⠐⠋⠀⠙⠳⣤⣠⠀⠀⠀⣀⠤⠒⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠵⡐⠄⠀⠀⠀⠀⠀⠀⠀⠈⢷⣄⡀⠀⠠⡀⠀⠈⠙⠶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡥⠈⠂⠀⠀⠀⠀⠀⠀⠀⣼⠉⠙⠲⣄⠈⠣⡀⠀⠀⠈⢻⡦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠈⣷⡄⠈⠄⠀⠀⠀⢧⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⡀⠀⢠⣿⣤⣤⣶⣶⣾⣿⣿⡄⢸⠀⠀⠀⢸⣄⣤⣼⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠇⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢸⠀⠀⠀⣼⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣀⣀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⢀⣼⣿⣿⣿⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠉⠁⠀⠈⠉⠙⠛⠿⠿⠽⠿⠟⠛⡉⠛⠲⣿⣿⠿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀⢠⡏⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀KraviGO⠀⠐⠋⠀⠀⣠⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢔⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠒⠁⠀⠀Avearr⠀⠀⠀⢀⠄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⡠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠊⠀⠀⠀⠀⠀⣃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡠⣻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⢫⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣰⡿⣿⣿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀MishZhem⠀⠀⠀⠘⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⣼⠏⣸⣿⣷⢷⠙⣻⢶⣤⣄⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠾⠉⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠰⣏⠀⣿⣿⡘⣼⡇⠀⠁⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠉⠁⠀⠀⣽⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢙⠓⠛⠘⣧⠾⢷⣄⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⣿⢟⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠸⠀⠀⠀⢸⣧⠀⠹⣆⠀⠀⠀⠀⠈⢻⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⣿⢂⠙⢿⡷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢃⠀⠀⠈⠙⠀⠀⠻⡄⠀⠀⠀⠀⠸⡀⠹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⠐⠠⠀⠻⠬⠄⡒⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠐⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠑⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
## Геома (даже 16 см есть!!!)

### 16

```
struct Vector
{
	long double x, y;

	Vector operator+(Vector v1) const
	{
		return { x + v1.x, y + v1.y };
	}

	Vector operator-(Vector v1) const
	{
		return { x - v1.x, y - v1.y };
	}

	Vector operator*(long double l) const
	{
		return{ x * l, y * l };
	}

	Vector operator/(long double l) const
	{
		return{ x / l, y / l };
	}

	bool operator==(Vector v1)
	{
		if (abs(x - v1.x) <= eps && abs(y - v1.y) <= eps)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Vector v1)
	{
		if (abs(x - v1.x) > eps || abs(y - v1.y) > eps)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	long double len()
	{
		return sqrt(x * x + y * y);
	}

	Vector norm()
	{
		long double l = len();

		return { x / len(), y / len() };
	}

	Vector set(long double f)
	{
		Vector nv = norm();

		return { nv.x * f, nv.y * f };
	}
};

struct Line
{
	long double a, b, c;
};

#define Point Vector

Point inv = { LLONG_MAX, LLONG_MAX };

long double dot(Vector v1, Vector v2)
{
	return v1.x * v2.x + v1.y * v2.y;
}

long double cross(Vector v1, Vector v2)
{
	return v1.x * v2.y - v1.y * v2.x;
}

Line make_line(Point p1, Point p2)
{
	long double a = p1.y - p2.y;
	long double b = p2.x - p1.x;
	long double c = -b * p1.y - a * p1.x;
	Vector v = { a,b };
	long double dist = v.len();
	return { a / dist, b / dist, c / dist };
}

Point intersec(Line l1, Line l2)
{
	if (l1.a * l2.b - l2.a * l1.b == 0 || l1.a * l2.b - l2.a * l1.b == 0)
	{
		return { (long double)LLONG_MAX, (long double)LLONG_MAX };
	}
	else
	{
		return { -(l1.c * l2.b - l2.c * l1.b) / (l1.a * l2.b - l2.a * l1.b),  -(l2.c * l1.a - l1.c * l2.a) / (l1.a * l2.b - l2.a * l1.b) };
	}
}

bool belongs_ray(Point p, Point p1, Point p2)
{
	Vector v1 = p2 - p1;
	Vector v2 = p - p1;

	if (((v1.x >= 0 && v2.x >= 0) || (v1.x <= 0 && v2.x <= 0)) && ((v1.y >= 0 && v2.y >= 0) || (v1.y <= 0 && v2.y <= 0)))
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool belongs_segment(Point p, Point p1, Point p2)
{
	if (belongs_ray(p, p1, p2) && belongs_ray(p, p2, p1))
	{
		return true;
	}
	else
	{
		return false;
	}
}

Point height(Point p, Line l)
{
	Line l2;
	l2.a = -l.b;
	l2.b = l.a;
	l2.c = -(l2.a * p.x + l2.b * p.y);

	return intersec(l, l2);
}

long double dist(Point p1, Point p2)
{
	Vector v = p2 - p1;

	return sqrt(v.x * v.x + v.y * v.y);
}

long double PP(Point p1, Point p2)
{
	return dist(p1, p2);
}

long double PS(Point p1, Point p2, Point p3)
{
	Point h = height(p1, make_line(p2, p3));

	if (belongs_segment(h, p2, p3))
	{
		return dist(p1, h);
	}
	else
	{
		return min(dist(p1, p2), dist(p1, p3));
	}
}

long double PR(Point p1, Point p2, Point p3)
{
	Point h = height(p1, make_line(p2, p3));

	if (belongs_ray(h, p2, p3))
	{
		return dist(p1, h);
	}
	else
	{
		return dist(p1, p2);
	}
}

long double PL(Point p1, Point p2, Point p3)
{
	return dist(p1, height(p1, make_line(p2, p3)));
}

long double SS(Point p1, Point p2, Point p3, Point p4)
{
	Point pint = intersec(make_line(p1, p2), make_line(p3, p4));

	if (pint != inv && belongs_segment(pint, p1, p2) && belongs_segment(pint, p3, p4))
	{
		return 0;
	}

	long double minh = LLONG_MAX;

	minh = min(minh, PS(p3, p1, p2));
	minh = min(minh, PS(p4, p1, p2));
	minh = min(minh, PS(p1, p3, p4));
	minh = min(minh, PS(p2, p3, p4));

	return minh;
}

long double SR(Point p1, Point p2, Point p3, Point p4)
{
	Point pint = intersec(make_line(p1, p2), make_line(p3, p4));

	if (pint != inv && belongs_segment(pint, p1, p2) && belongs_ray(pint, p3, p4))
	{
		return 0;
	}

	long double minh = LLONG_MAX;

	minh = min(minh, PS(p3, p1, p2));
	minh = min(minh, PR(p1, p3, p4));
	minh = min(minh, PR(p2, p3, p4));

	return minh;
}

long double SL(Point p1, Point p2, Point p3, Point p4)
{
	Point pint = intersec(make_line(p1, p2), make_line(p3, p4));

	if (pint != inv && belongs_segment(pint, p1, p2))
	{
		return 0;
	}

	long double minh = LLONG_MAX;

	minh = min(minh, PS(p3, p1, p2));
	minh = min(minh, PS(p4, p1, p2));
	minh = min(minh, PL(p1, p3, p4));
	minh = min(minh, PL(p2, p3, p4));

	return minh;
}

long double RR(Point p1, Point p2, Point p3, Point p4)
{
	Point pint = intersec(make_line(p1, p2), make_line(p3, p4));

	if (pint != inv && belongs_ray(pint, p1, p2) && belongs_ray(pint, p3, p4))
	{
		return 0;
	}

	long double minh = LLONG_MAX;

	minh = min(minh, PR(p3, p1, p2));
	minh = min(minh, PR(p1, p3, p4));

	return minh;
}

long double RL(Point p1, Point p2, Point p3, Point p4)
{
	Point pint = intersec(make_line(p1, p2), make_line(p3, p4));

	if (pint != inv && belongs_ray(pint, p1, p2))
	{
		return 0;
	}

	long double minh = LLONG_MAX;

	minh = min(minh, PR(p3, p1, p2));
	minh = min(minh, PR(p4, p1, p2));
	minh = min(minh, PL(p1, p3, p4));

	return minh;
}

long double LL(Point p1, Point p2, Point p3, Point p4)
{
	Point pint = intersec(make_line(p1, p2), make_line(p3, p4));

	if (pint != inv)
	{
		return 0;
	}

	long double minh = LLONG_MAX;

	minh = min(minh, PL(p3, p1, p2));
	minh = min(minh, PL(p4, p1, p2));
	minh = min(minh, PL(p1, p3, p4));
	minh = min(minh, PL(p2, p3, p4));

	return minh;
}
```

### Структура вектора и выпуклая оболочка
```
struct r {
    int x, y;
 
    r() {};
 
    r(int x, int y) : x(x), y(y) {}
 
    double angle() {
        return atan2(y, x);
    }
 
    ll len() {
        return x * x + y * y;
    }
};
 
r operator+(r a, r b) { return {a.x + b.x, a.y + b.y}; }
 
r operator-(r a, r b) { return {a.x - b.x, a.y - b.y}; }
 
int operator*(r a, r b) { return a.x * b.x + a.y * b.y; } // скалярное произведение
int operator^(r a, r b) { return a.x * b.y - b.x * a.y; } // векторное произведение
 
istream &operator>>(istream &in, r &p) {
    in >> p.x >> p.y;
    return in;
}
 
ostream &operator<<(ostream &out, r &p) {
    out << p.x << " " << p.y << eol;
    return out;
}
 
ll dist(r a, r b) {
    return sqr(a.x - b.x) + sqr(a.y - b.y);
}

bool is_in(r a, r b, r c, r p) {
    return ((b - a) ^ (p - a)) >= 0 and
           ((c - b) ^ (p - b)) >= 0 and
           ((a - c) ^ (p - c)) >= 0;
 
}

bool comp(r a, r b) {
    if ((a ^ b) == 0)
        return a.len() < b.len();
    return (a ^ b) > 0;
}
 
vector<r> graham(vector<r> points) {
    r p0 = points[0];
    for (r p : points) {
        if (p.y < p0.y or (p.y == p0.y and p.x < p0.x)) {
            p0 = p;
        }
    }
    for (r &p : points) { p = p - p0; }
 
    sort(points.begin(), points.end(), comp);
    
    vector<r> hull;
    hull.push_back(points[0]);
    hull.push_back(points[1]);
 
    for (int i = 2; i < points.size(); i++) {
        r p = points[i];
        while (hull.size() >= 2 and
               ((hull[hull.size() - 1] - hull[hull.size() - 2]) ^ (p - hull[hull.size() - 2])) <= 0){
            hull.pop_back();
        }
        hull.push_back(p);
    }
 
    for (r &p : hull) { p = p + p0; }
    return hull; 
}
```


### Точка внутри выпуклой оболочки? O(log(n))
```
r start = points[0];
int l = 0, r = n-1;
while (r - l > 1) {
    int mid = (l + r) / 2;
    if (((points[mid] - start) ^ (p - start)) >= 0) {
        l = mid;
    } else {
        r = mid;
    }
}
if (is_in(start, points[l], points[r], p)) {
    // IN HULL
}
```

---

## ДФС и кратчайшие пути

### LCA (bin-up)

```
int MaxD = 20;
vector<vector<int>> binup;
vector <int> d;

int up(int u, int x){
    int j = 0;
    while (x > 0){
        if (x % 2 > 0) u = binup[u][j];
        x /= 2;
        j++;
    }
    return u;
}

int lca(int a, int b){
    if (d[b] > d[a]) swap(a, b);
    a = up(a, d[a] - d[b]);
    if (a == b) return a;
    for (int i = MaxD - 1; i >= 0; i--){
        if (binup[a][i] != binup[b][i]){
            a = binup[a][i];
            b = binup[b][i];
        }
    }
    return binup[a][0];
}

int main(){
    binup = vector<vector<int>>(n + 1, vector <int>(MaxD, 1));
    d.resize(n + 1);
    d[1] = 0;
    for (int i = 0; i < n; i++){
        string s; cin >> s;
        if (s == "ADD"){
            int a, b; cin >> a >> b;
            d[b] = d[a] + 1;
            binup[b][0] = a;
            for (int j = 1; j < MaxD; j++){
                binup[b][j] = binup[binup[b][j - 1]][j - 1];
            }
        }
        if (s == "GET"){
            int a, b; cin >> a >> b;
            cout << lca(a,b) << '\n';
        }
    }
    return 0;
}
```

### LCA (sparse table)

```
ll n, m;
ll a1, a2;
ll x, y, z;
vector<vector<ll>> g;
vector<pair<ll, ll>> eulerWay;
vector<ll> tinId, a;
pair<ll, ll> table[21][(int)2e5 + 10];

void init() {
    g.resize(n);
    tinId.resize(n);
    a.resize(2*m+1);
}

void dfs(ll v, ll p, ll t) {
    eulerWay.push_back({t, v});
    tinId[v] = eulerWay.size() - 1;
    for (auto to : g[v]) {
        if (to == p) continue;
        dfs(to, v, t + 1);
        eulerWay.push_back({t, v});
    }
}

void initSparseTable() {
    ll maxlog = 20;
    memset(table, 1, sizeof(table));
    for (int i = 0; i < (int)eulerWay.size(); i++) {
        table[0][i].first = eulerWay[i].first;
        table[0][i].second = eulerWay[i].second;
    }

    for (int j = 1; j < maxlog; ++j) {
        for (int i = 0, lim = (int)eulerWay.size() - (1 << (j)); i < lim; ++i) {
            table[j][i] = min(table[j - 1][i], table[j - 1][i + (1 << (j - 1))]);
        }
    }
}

ll lca(ll l, ll r) {
    l = tinId[l], r = tinId[r];
    if (l > r) swap(l, r);
    ll t = log2(r - l);
    return min(table[t][l], table[t][r + 1LL - (1LL << t)]).second;
}

```

### HLD
```
const int maxn = 1e5 + 7;
ll t[4 * maxn];
int n, m;
vector<int> g[maxn];
vb used;
int s[maxn], tin[maxn], tout[maxn], pr[maxn];
int head[maxn]; // «голова» тяжелого пути, которому принадлежит v
int timer = 0;
vll a, b;
 
 
const int INF = 1e9;
 
void update(int v) {
    t[v] = max(t[2 * v], t[2 * v + 1]);
}
 
int merge(int a, int b) {
    return max(a, b);
}
 
void build(int tl, int tr, int v) {
    if (tl + 1 == tr) {
        t[v] = b[tl];
        return;
    }
    int mid = (tl + tr) / 2;
    build(tl, mid, 2 * v);
    build(mid, tr, 2 * v + 1);
    update(v);
}
 
ll get(int tl, int tr, int v, int l, int r) {
    if (l <= tl and tr <= r) {
        return t[v];
    }
    if (tl >= r or tr <= l) {
        return 0;
    }
    int mid = (tl + tr) / 2;
    return merge(get(tl, mid, 2 * v, l, r), get(mid, tr, 2 * v + 1, l, r));
}
 
void set_(int tl, int tr, int v, int ind, int val) {
    if (tl + 1 == tr and tl == ind) {
        t[v] = val;
        return;
    }
    if (ind < tl or ind >= tr) return;
 
    int mid = (tl + tr) / 2;
    set_(tl, mid, 2 * v, ind, val);
    set_(mid, tr, 2 * v + 1, ind, val);
    t[v] = merge(t[2 * v], t[2 * v + 1]);
}
 
 
void sizes(int v, int p) {
    s[v] = 1;
    for (int &u : g[v]) {
        if (u == p) continue;
        sizes(u, v);
        s[v] += s[u];
        if (s[u] > s[g[v][0]] or g[v][0] == p)
            // &u -- это ссылка, так что её легально использовать при swap-е
            swap(u, g[v][0]);
    }
}
 
void hld(int v, int p) {
    tin[v] = timer++;
 
    if (p == -1) head[v] = v;
    for (int to : g[v]) {
        if (to == p) continue;
        pr[to] = v;
 
        if (to == g[v][0]) head[to] = head[v]; // тяжелый чел
        else head[to] = to; // легкий чел
        hld(to, v);
    }
    tout[v] = timer;
}
 
bool is_anc(int &a, int &b) {
    return tin[a] <= tin[b] && tin[b] < tout[a];
}
 
void up(int &a, int &b, ll &ans) {
    while (!is_anc(head[a], b)) {
        ans = max(ans, get(0, n, 1, tin[head[a]], tin[a] + 1));
//        cout << "up " << a <<":" <<tin[a] << " " << b << ":"<< tin[b] << " " << get(0, n, 1, tin[a], tin[b] + 1) << eol;
        a = pr[head[a]];
    }
}
 
ll get_ans(int a, int b) {
    ll ans = 0;
    up(a, b, ans);
    up(b, a, ans);
    if (!is_anc(a, b)) swap(a, b);
//    cout << a << " " << b << " " << ans << eol;
    ans = max(ans, get(0, n, 1, tin[a], tin[b] + 1));
    return ans;
}
 
void print_tree() {
    fori(n) {
        cout << get(0, n, 1, i, i + 1) << " ";
    }
    cout << eol;
}
 
int main() {
    Fastio();
    cin >> n;
    a.resize(n);
    b.resize(n);
    read(a);
    fori(n - 1) {
        int v, u;
        cin >> v >> u;
        u--;
        v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    sizes(0, -1);
    hld(0, -1);
    fori(n) b[tin[i]] = a[i];
    build(0, n, 1);
    cin >> m;
    fori(m) {
        char c;
        ll v, u, x;
        cin >> c;
        if (c == '?') {
            cin >> v >> u;
            v--;
            u--;
            cout << get_ans(v, u) << eol;
 
        } else {
            cin >> v >> x;
            v--;
            set_(0, n, 1, tin[v], x);
            b[tin[v]] = x;
        }
//        print_tree();
    }
```

### Мосты
```
struct node{
    int v, i;
};
 
const int MAXN = 1e5;
vector<node> g[MAXN];
vb used;
int t = 0, n, tin[MAXN], fup[MAXN];
vector<pair<int, int>> bridges;
vi bridges_i;
 
void dfs (int v, int p = -1, int pi = -1) {
    used[v] = true;
    tin[v] = fup[v] = t++;
    for (auto e: g[v]) {
        int to = e.v;
        if (e.i == pi) continue;
 
        if (used[to])
            fup[v] = min (fup[v], tin[to]);
        else {
            dfs (to, v, e.i);
            fup[v] = min (fup[v], fup[to]);
            if (fup[to] > tin[v]){
                bridges_i.push_back(e.i);
                //bridges.push_back({v, to});
            }
        }
    }
}
void find_bridges() {
    t = 0;
    used = vb(MAXN, false);
    fore(i, 0, n) {
        if (!used[i])
            dfs(i);
    }
}
```

### Точки сочленения
```
void dfs (int v, int p = -1) {
    used[v] = true;
    tin[v] = dp[v] = t++;
    int children = 0;
    for (auto to: g[v]) {
        if (to == p) continue;
        if (used[to])
            dp[v] = min(dp[v], tin[to]);
        else {
            dfs(to, v);
            dp[v] = min(dp[v], dp[to]);
            if (dp[to] >= tin[v] && p != -1) {
                cut_point.insert(v);
            }
            ++children;
        }
    }
    if (p == -1 && children > 1)
        cut_point.insert(v);
}
```

### Дейкстра
```
vector<int> dijkstra(int s) {
    vector<int> d(n, inf);
    d[root] = 0;
    // объявим очередь с приоритетами для *минимума* (по умолчанию ищется максимум)
    using pair<int, int> Pair;
    priority_queue<Pair, vector<Pair>, greater<Pair>> q;
    q.push({0, s});
    while (!q.empty()) {
        auto [cur_d, v] = q.top();
        q.pop();
        if (cur_d > d[v])
            continue;
        for (auto [u, w] : g[v]) {
            if (d[u] > d[v] + w) {
                d[u] = d[v] + w;
                q.push({d[u], u});
            }
        }
    }
}
```

### Форд-Беллман
```
struct edge{
        int v, to, w;
};
 
void relax(edge e, vll & d){
    d[e.to] = min(d[e.v] + e.w, d[e.to]);
}
 
int main() {
    Fastio();
    int n, m; cin >> n >> m;
    vector<edge> edges;
    fori(m){
        int v, u, w;
        cin >> v >> u >> w;
        if (v == u) continue;
        edges.push_back({--v, --u, w});
    }
    int INF = 30000;
    vll dist(n, INF);
    dist[0] = 0;
 
    fore(i, 0, n){
        for(auto edge: edges){
            if (dist[edge.v] == INF and dist[edge.to] == INF) continue;
            //cout << edge.v << " " << edge.to << eol;
            relax(edge, dist);
        }
    }
    print(dist);
}
```


---

## Матеша нужно кто 

### Разный функции
```
ll binpow(ll a, ll n, ll mod) {
    if (n == 0)
        return 1;
    if (n % 2 == 0)
        return binpow((a * a) % mod, n / 2, mod);
    else
        return (a * binpow(a, n - 1, mod)) % mod;
}
 
ll binpow_1(ll a, ll n, ll mod) {
    ll res = 1;
    while (n) {
        if (n & 1)
            res = (res * a) % mod;
        a = (a * a) % mod;
        n >>= 1;
    }
    return res % mod;
}
 
ll phi(ll n) {
    ll res = n;
    for (int p = 2 ; p * p <= n ; ++p) {
        if (n % p == 0)
            res -= res / p;
        while (n % p == 0)
            n /= p;
    }
    if (n > 1)
        res -= res / n;
    return res;
}
 
ll inv_prime(ll a, ll m) {
    return binpow_1(a, m - 2, m);
}
 
ll inv(ll a, ll m) {
    return binpow_1(a % m, phi(m) - 1, m);
}
 
ll gcd_ext(ll a, ll b, ll &x, ll &y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    ll x1, y1;
    ll d = gcd_ext(b % a, a, x1, y1);
    x = y1 - (b / a) * x1;
    y = x1;
    return d;
}
 
void solve() {
    ll a, m;
    cin >> a >> m;
    ll x, y;
    ll g = gcd_ext(a, m, x, y);
    if (g != 1) {
        cout << -1;
    } else {
        x = (x % m + m) % m;
        cout << x;
    }
}
```

### КТО
```
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll gcdext(ll a, ll b, ll &x, ll &y) {
    if (a == 0) {
        x = 0, y = 1;
        return b;
    }
    ll x1, y1;
    ll d = gcdext(b % a, a, x1, y1);
    x = y1 - (b / a) * x1;
    y = x1;
    return d;
}

void solve() {
    ll a, b, n, m;
    cin >> a >> b >> n >> m;

    ll d = gcd(n, m);
    if (((b - a) % d + d) % d) {
        cout << "NO\n";
        return;
    }

    ll n1, m1;
    gcdext(n / d, m / d, n1, m1);

    ll mod = m / d;
    ll k = ((((b - a) / d) * n1) % mod + mod) % mod;
    ll p = (n * m) / d;
    ll x = ((a + n * k) % p + p) % p;

    cout << "YES" << " " << x << " " << p << '\n';
}

```

### Сжатие координат
```
vector<int> compress(vector<int> a) {
    vector<int> b = a;
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());
    for (int &x : a)
        x = int(lower_bound(b.begin(), b.end(), x) - b.begin());
    return a;
}
```






## Строки

### N, P функции
```
vi z_function (string s) {
    int n = (int) s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    z[0] = n;
    return z;
}
vi p_function (string s) {
    int n = (int) s.length();
    vi pi (n);
    fore(i, 1, n) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])  ++j;
        pi[i] = j;
    }
    return pi;
}
 ```

### Хорошие хеши
```
struct hashed_string {
    vll h;
    vll rh;
    vll P;
    int n;
    int c = 31;
    const int mod = 1e9 + 7;
    hashed_string(string s) {
        n = s.length();
        h.assign(n, 0);
        rh.assign(n, 0);
        P.assign(n, 1);
        h[0] = s[0] - 'a' + 1;
        rh[0] = s[n - 1] - 'a' + 1;
        for (int i = 1; i < n; i++) {
            P[i] = (P[i - 1] * c) % mod;
            h[i] = (h[i - 1] * c + (s[i] - 'a' + 1)) % mod;
            rh[i] = (rh[i - 1] * c + (s[n - 1 - i] - 'a' + 1)) % mod;
        }
    }

    ll getHash(int l, int r) {
        if (l == 0) {
            return h[r];
        } else {
            return ((h[r] - (h[l - 1] * P[r - l + 1])) % mod + mod) % mod;
        }
    }

    ll getReverseHash(int l, int r) {
        if (r == n - 1) {
            return rh[n - l - 1];
        } else {
            return ((rh[n - l - 1] - (rh[n - r - 2] * P[r - l + 1])) % mod + mod) % mod;
        }
    }

    bool isPalindrome(int l, int r) {
        if (l == r) return true;
        if ((r - l + 1) % 2 == 0) {
            return (getHash(l, (l + r) / 2) == getReverseHash((l + r) / 2 + 1, r));
        } else {
            return (getHash(l, (l + r) / 2 - 1) == getReverseHash((l + r) / 2 + 1, r));
        }
    }
};
```









## Структуры

### ДО + сканлайн (объединение прямоугольников со сжатием)

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
const ll INF = 1e18;
 
struct point{
    ll x, y;
    point operator+(ll d) {
        return {x + d, y + d};
    }
};
struct qs{point pl, pr; int type;};
 
bool cmp(qs a, qs b) {
    if (a.pl.x == b.pl.x) {
        return a.type < b.type;
    }
    return a.pl.x < b.pl.x;
}
 
struct Node{
    ll minEl, cnt;
 
    Node operator+(Node other) {
        Node tmp;
        tmp.minEl = min(minEl, other.minEl);
        if (minEl == other.minEl) {
            tmp.cnt = cnt + other.cnt;
        } else if (minEl < other.minEl) {
            tmp.cnt = cnt;
        } else {
            tmp.cnt = other.cnt;
        }
        return tmp;
    }
};
 
const Node neutral = {INF, 0};
vector<Node> tree;
vector<ll> p;
 
void build(vector<ll> &a, int v, int tl, int tr) {
    if (tl + 1 == tr) {
        tree[v] = {0, a[tl]};
        return;
    }
    int m = (tl + tr) / 2;
    build(a, 2*v + 1, tl, m);
    build(a, 2*v + 2, m, tr);
    tree[v] = tree[2*v + 1] + tree[2*v + 2];
}
 
void push(int v, int tl, int tr) {
    if (p[v] == 0) return;
    if (tl + 1 == tr) return;
    tree[2*v + 1].minEl += p[v];
    tree[2*v + 2].minEl += p[v];
    p[2*v + 1] += p[v];
    p[2*v + 2] += p[v];
    p[v] = 0;
}
 
Node get(int l, int r, int v, int tl, int tr) {
    push(v, tl, tr);
    if (tl >= r || tr <= l) return neutral;
    if (tl >= l && tr <= r) return tree[v];
    int m = (tl + tr) / 2;
    return get(l, r, 2*v + 1, tl, m) + get(l, r, 2*v + 2, m, tr);
}
 
void upd(int l, int r, ll d, int v, int tl, int tr) {
    push(v, tl, tr);
    if (tl >= r || tr <= l) return;
    if (tl >= l && tr <= r) {
        tree[v].minEl += d;
        p[v] = d;
        return;
    }
    int m = (tl + tr) / 2;
    upd(l, r, d, 2*v + 1, tl, m);
    upd(l, r, d, 2*v + 2, m, tr);
    tree[v] = tree[2*v + 1] + tree[2*v + 2];
}
 
 
ll k, n, h, tSz;
vector<qs> cords;
set<ll> yComp, xComp;
vector<ll> xs, ys;
 
void addRec(point p1, point p2) {
    cords.push_back({p1, p2, 1});
    cords.push_back({p2, p1, -1});
    xComp.insert(p1.x);
    xComp.insert(p2.x);
    yComp.insert(p1.y);
    yComp.insert(p2.y);
}
 
void updLineY(int i, int &j) {
    while (j < cords.size() && cords[j].pl.x == xs[i]) {
        int l = lower_bound(ys.begin(), ys.end(), cords[j].pl.y) - ys.begin();
        int r = lower_bound(ys.begin(), ys.end(), cords[j].pr.y) - ys.begin();
        if (l > r) swap(l, r);
        upd(l, r, cords[j].type, 0, 0, tSz);
        j++;
    }
}
 
void solve() {
    cin >> k >> n;
 
    point cur = {0, 0};
    for (int i = 0; i < n; i++) {
        char c; cin >> c;
        ll x; cin >> x;
        point tmpCur = cur;
        if (c == 'W') {
            cur.x -= x;
            addRec(cur, tmpCur + k);
        } else if (c == 'N') {
            cur.y += x;
            addRec(tmpCur, cur + k);
        } else if (c == 'E') {
            cur.x += x;
            addRec(tmpCur, cur + k);
        } else {
            cur.y -= x;
            addRec(cur, tmpCur + k);
        }
    }
 
    sort(cords.begin(), cords.end(), cmp);
 
    h = 0;
    xs = vector<ll>(xComp.begin(), xComp.end());
    ys = vector<ll>(yComp.begin(), yComp.end());
 
    vector<ll> tmpD(ys.size()-1);
    tSz = tmpD.size();
    for (int i = 1; i < ys.size(); i++) {
        tmpD[i-1] = ys[i] - ys[i-1];
        h += tmpD[i-1];
    }
 
    tree.resize(tSz * 4);
    p.resize(tSz * 4);
    build(tmpD, 0, 0, tSz);
    
    int j = 0;
    updLineY(0, j);
 
    ll ans = 0;
    for (int i = 1; i < xs.size(); i++) {
        Node qw = get(0, tSz, 0, 0, tSz);
        if (qw.minEl != 0) qw.cnt = 0;
        ans += (xs[i] - xs[i-1]) * (h - qw.cnt);
        updLineY(i, j);
    }
 
    cout << ans;
}

```

### ДД по неявному ключу

```
ll INF = 1e9 + 7;
 
struct Node {
    ll x, y, size = 1;
    Node *left;
    Node *right;
 
    Node(int k) {
        x = k;
        y = rnd();
        left = right = nullptr;
    }
};
 
int sz(Node *t) {
    if (t == nullptr) return 0;
    else return t->size;
}
 
void upd(Node *t) {
    t->size = sz(t->left) + sz(t->right) + 1;
}
 
pair<Node *, Node *> split(Node *t, ll k) {
    if (t == nullptr) return {nullptr, nullptr};
 
    if (sz(t->left) < k) {
        auto[tl, tr] = split(t->right, k - sz(t->left) - 1);
        t->right = tl;
        upd(t);
        return {t, tr};
    } else {
        auto[tl, tr] = split(t->left, k);
        t->left = tr;
        upd(t);
        return {tl, t};
    }
}
 
 
Node *merge(Node *t1, Node *t2) {
    if (t1 == nullptr) return t2;
    if (t2 == nullptr) return t1;
 
    if (t1->y > t2->y) {
        t1->right = merge(t1->right, t2);
        upd(t1);
        return t1;
    } else {
        t2->left = merge(t1, t2->left);
        upd(t2);
        return t2;
    }
}
 
Node *insert(Node *t, int k) {
    Node *node = new Node(k);
    auto[tl, tr] = split(t, k);
    t = merge(tl, node);
    t = merge(t, tr);
    return t;
}

ll get_k(Node * t, ll k){
    if (sz(t->left) + 1 == k)return t->x;
    if (sz(t->left) >= k) return get_k(t->left, k);
    else return get_k(t->right, k - sz(t->left) - 1);
}
 
//#define DEBUG
//#if DEBUG
void printD(Node *t) {
    if (t == nullptr) return;
    printD(t->left);
    cout << t->x << " ";
    printD(t->right);
}
 
void printDD(Node *t) {
    printD(t);
    cout << eol;
}
//#endif
```

### Фенвик 3д

```
ll n;
vvvll t;
 
int F(int i){
    return (i & (i+1)) - 1;
}
 
ll sum(int x, int y, int z){
    ll res = 0;
    int old_y = y, old_z = z;
 
    for( ; x >= 0; x = F(x)){
        for( ; y >= 0; y = F(y)){
            for( ;z >= 0; z = F(z)){
                //cout << "sum";
                res += t[x][y][z];
            }
            z = old_z;
        }
        y = old_y;
    }
    return res;
}
 
int E(int i){
    return i | (i + 1);
}
 
void update(int x, int y, int z, ll delta){
    int old_y = y, old_z = z;
    for (; x < n; x = E(x)){
        for (; y < n; y = E(y)){
            for (; z < n; z = E(z)){
                t[x][y][z] += delta;
            }
            z = old_z;
        }
        y = old_y;
    }
}
 
 
int main(){
    Fastio();
    int m;
    cin >> n;
    t.resize(n);
    for(int i = 0; i < n; i ++){
        t[i].resize(n);
        for (int j = 0; j < n; j++){
            t[i][j].resize(n);
        }
    }
    bool flag = true;
 
    while(flag){
        cin >> m;
        if(m == 1){
            int x, y, z;
            ll val;
            cin >> x >> y >> z >> val;
            update(x, y, z, val);
        }
        else if (m == 2){
            int lx, ly, lz, rx, ry, rz;
            cin >> lx >> ly >> lz >> rx >> ry >> rz;
            lx --;
            ly--;
            lz--;
            ll summ = sum(rx, ry, rz)
                      - sum(lx, ry, rz) - sum(rx, ly, rz) - sum(rx, ry, lz)
                      + sum(rx, ly, lz) + sum(lx, ry, lz) + sum(lx, ly, rz)
                      - sum(lx, ly, lz);
            cout << summ << endl;
        } else{
            flag = false;
        }
    }
 
 
}
```

## MST
### Ээээээээль Примо (n^2)
```
vector <ld> d(n, INF);
vector <bool> used(n);
d[0] = 0;
for (int i = 0; i < n; i++) {
    int v = -1;
    for (int j = 0; j < n; j++) {
        if (used[j]) continue;
        if (v == -1 || d[j] < d[v]) v = j;
    }

    used[v] = 1;
    for (int j = 0; j < n; j++) {
        if (used[j]) continue;
        if (f(a[v], a[j]) < d[j]) {
            d[j] = f(a[v], a[j]);
        }
    }
}
```

### СНМ
```
int p[N];
ll w[N];

int get(int x) {
    return (p[x] == x ? x : p[x] = get(p[x]));
}

void join(int x, int y) {
    int a = get(x), b = get(y);
    if (a == b) return;
    if (w[a] > w[b]) swap(a, b);
    w[b] += w[a];
    p[a] = b;
}
```

### Крускал (M log N)
```
int n, m;
vector <edge> g;

bool cmp(edge a, edge b) {
    return a.w < b.w;
}

void solve() {
    cin >> n >> m;
    readGraph();
    sort(g.begin(), g.end(), cmp);

    for (int i = 0; i < N; i++) p[i] = i;
    for (int i = 0; i < N; i++) w[i] = 1;

    ll ans = 0;
    for (auto e : g) {
        if (get(e.from) != get(e.to)) {
            join(e.from, e.to);
            ans += e.w;
        }
    }

    cout << ans;
}

```


## Всякая всячина

### MO
```
struct Q {
    int l, r, i;
};
 
int c = 500;
 
bool cmp(Q a, Q b) {
    if (a.l / c == b.l / c)
        return a.r < b.r;
    return a.l < b.l;
}
 
 
signed main() {
    Fastio();
    ll n, m;
    cin >> n >> m;
 
    vector<Q> req;
    vll a(n), cnt(n + 1);
    read(a);
    vll ans(m);
 
    fori(m) {
        int l, r;
        cin >> l >> r;
        req.push_back({--l, --r, i});
    }
 
    sort(all(req), cmp);
    int cur_ans = 0;
    int l = 0, r = -1;
 
    for (Q q : req) {
        while (r < q.r) {
            r++;
            if (a[r] > n) continue;
            cnt[a[r]]++;
            if (cnt[a[r]] == a[r]) cur_ans++;
            if (cnt[a[r]] == a[r] + 1) cur_ans--;
        }
        while (r > q.r) {
            if (a[r] > n) {
                r--;
                continue;
            }
            if (cnt[a[r]] == a[r]) cur_ans--;
            if (cnt[a[r]] - 1 == a[r]) cur_ans++;
 
            cnt[a[r]]--;
            r--;
        }
 
        while (l < q.l) {
            if (a[l] > n) {
                l++;
                continue;
            }
            if (cnt[a[l]] == a[l]) cur_ans--;
            if (cnt[a[l]] - 1 == a[l]) cur_ans++;
 
            cnt[a[l]]--;
            l++;
        }
        while (l > q.l) {
            l--;
            if (a[l] > n) continue;
            cnt[a[l]]++;
            if (cnt[a[l]] == a[l]) cur_ans++;
            if (cnt[a[l]] == a[l] + 1) cur_ans--;
 
        }
        ans[q.i] = cur_ans;
    }
    print(ans);
}
```

### ГИСТАРАМААААААААА СПАСИТИ ПАМАГИТИ

```
for (int i = 1; i <= n + 1; ++i) {
    while (a[i] < a[st.top()]) {
        ll k = st.top();
        ansr[k] = i;
        st.pop();
    }
    st.push(i);

}
st = {};
st.push(0);
for (int i = n; i >= 1; --i) {
    while (a[i] < a[st.top()]) {
        ll k = st.top();
        ansl[k] = i;
        st.pop();
    }
    st.push(i);

}
//    print(ansl);
//    print(ansr);
for (int i = 1; i <= n; ++i) {
    res = max(res, (ansr[i] - ansl[i] - 1) * a[i]);
}
cout << res;
}
```

### Шапка
```
#include <bits/stdc++.h>
 
#pragma GCC optimize("Ofast", "O3", "unroll-loops", "fast-math")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,
                    abm,mmx,avx,avx2,fma,tune=native")
 
//#define int long long
//#define ll unsigned long long
 
/*
//for ordered set
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>

//ordered_set X;
//X.find_by_order(1);
//X.order_of_key(-5);
*/
 
using namespace std;
 
typedef unsigned long long ull;
typedef long double ld;
typedef long long ll;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<bool> vb;
typedef vector<vb> vvb;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<pll, pll> ppll;
 
 
template<class T>
void print(T &v) {
    for (auto el: v) { cout << el << " "; }
    cout << "\n";
}
 
template<class T>
void print_2d(T &vv) {
    for (auto v: vv) {
        for (auto el: v) { cout << el << " "; }
        cout << "\n";
    }
    cout << "\n";
}
 
template<class T>
void print_pairs(T &v) {
    cout << v.size() << "\n";
    for (auto el: v) {
        cout << el.first << " " << el.second << "\n";
    }
    cout << "\n";
 
}
 
#define Fastio() {ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);}
#define popcount(x) __builtin_popcount(x)
#define fore(i, l, r) for (int i = int(l); i < int(r); i++)
#define unq(x) (x.resize(unique(all(x)) - x.begin()))
#define read(arr) {for (auto & x : arr) cin >> x;}
#define deb(x) cout << #x << " = " << x << '\n';
#define fori(n) for (int i = 0; i < n; i++)
#define sqr(x) (x)*(x)
#define all(a) (a).begin(), (a).end()
#define fi first
#define se second
#define eol '\n'
 
template<class T1, class T2>
ostream &operator<<(ostream &o, pair<T1, T2> x) { return o << x.fi << ',' << x.se; }
 
template<class T1, class T2>
istream &operator>>(istream &o, pair<T1, T2> &x) { return o >> x.fi >> x.se; }
 
mt19937_64 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());
 
```